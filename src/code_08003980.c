#include "global.h"
#include "code_08003980.h"

asm(".include \"include/gba.inc\"");//Temporary

// Can be better split

static s32 D_030005c8[96]; // unknown type
static s32 D_03000748[6]; // unknown type
static s32 D_03000760[80]; // unknown type
static s16 D_030008a0; // unknown type
static s16 D_030008a2; // unknown type
static s16 D_030008a4; // unknown type
static s16 D_030008a6; // unknown type
static s16 D_030008a8; // unknown type
static s16 D_030008aa; // unknown type
static s8 D_030008ac; // unknown type
static s8 D_030008ad; // unknown type
static s32 D_030008b0[2]; // unknown type
static s32 D_030008b8[16]; // unknown type
static s32 D_030008f8[2]; // unknown type
static s32 D_03000900[2]; // unknown type
static s32 D_03000908[336]; // unknown type

#include "asm/code_08003980/asm_08003980.s"

#include "asm/code_08003980/asm_080039a8.s"

#include "asm/code_08003980/asm_080039d4.s"

#include "asm/code_08003980/asm_080039e8.s"

#include "asm/code_08003980/asm_08003a00.s"

#include "asm/code_08003980/asm_08003a18.s"

#include "asm/code_08003980/asm_08003a34.s"

#include "asm/code_08003980/asm_08003a40.s"

#include "asm/code_08003980/asm_08003a50.s"

#include "asm/code_08003980/asm_08003a6c.s"

#include "asm/code_08003980/asm_08003a78.s"

#include "asm/code_08003980/asm_08003a88.s"

#include "asm/code_08003980/asm_08003aa4.s"

#include "asm/code_08003980/asm_08003ab8.s"

#include "asm/code_08003980/asm_08003ac4.s"

#include "asm/code_08003980/asm_08003b28.s"

#include "asm/code_08003980/asm_08003b34.s"

#include "asm/code_08003980/asm_08003bd4.s"

#include "asm/code_08003980/asm_08003c18.s"

#include "asm/code_08003980/asm_08003c1c.s"

#include "asm/code_08003980/asm_08003de0.s"

#include "asm/code_08003980/asm_08003dec.s"

#include "asm/code_08003980/asm_08003e00.s"

#include "asm/code_08003980/asm_08003e64.s"

#include "asm/code_08003980/asm_08003ea4.s"

#include "asm/code_08003980/asm_08003eb8.s"

#include "asm/code_08003980/asm_08003f28.s"

#include "asm/code_08003980/asm_08003f50.s"

#include "asm/code_08003980/asm_08003fb4.s"

#include "asm/code_08003980/asm_08003ff0.s"

#include "asm/code_08003980/asm_0800402c.s"

#include "asm/code_08003980/asm_08004058.s"

#include "asm/code_08003980/asm_08004070.s"

#include "asm/code_08003980/asm_080041d0.s"

#include "asm/code_08003980/asm_08004248.s"

#include "asm/code_08003980/asm_0800425c.s"

#include "asm/code_08003980/asm_08004270.s"

#include "asm/code_08003980/asm_080042a4.s"

#include "asm/code_08003980/asm_080042bc.s"

#include "asm/code_08003980/asm_080043c8.s"

#include "asm/code_08003980/asm_080044f0.s"

#include "asm/code_08003980/asm_08004508.s"

#include "asm/code_08003980/asm_08004574.s"

#include "asm/code_08003980/asm_0800459c.s"

#include "asm/code_08003980/asm_080045b4.s"

#include "asm/code_08003980/asm_080045d0.s"

#include "asm/code_08003980/asm_080045fc.s"

#include "asm/code_08003980/asm_08004628.s"

#include "asm/code_08003980/asm_0800467c.s"

#include "asm/code_08003980/asm_080046c0.s"

#include "asm/code_08003980/asm_08004714.s"

#include "asm/code_08003980/asm_08004748.s"

#include "asm/code_08003980/asm_0800477c.s"

#include "asm/code_08003980/asm_0800496c.s"

#include "asm/code_08003980/asm_080049a0.s"

#include "asm/code_08003980/asm_080049dc.s"

#include "asm/code_08003980/asm_080049f0.s"

#include "asm/code_08003980/asm_08004b60.s"

#include "asm/code_08003980/asm_08004b70.s"

#include "asm/code_08003980/asm_08004b88.s"

#include "asm/code_08003980/asm_08004b98.s"

#include "asm/code_08003980/asm_08004bfc.s"

#include "asm/code_08003980/asm_08004c0c.s"

#include "asm/code_08003980/asm_08004c40.s"

#include "asm/code_08003980/asm_08004c50.s"

#include "asm/code_08003980/asm_08004cac.s"

#include "asm/code_08003980/asm_08004ccc.s"

#include "asm/code_08003980/asm_08004d44.s"

#include "asm/code_08003980/asm_08004da0.s"

#include "asm/code_08003980/asm_08004dc0.s"

#include "asm/code_08003980/asm_08004e60.s"

#include "asm/code_08003980/asm_08004e88.s"

#include "asm/code_08003980/asm_08004eac.s"

#include "asm/code_08003980/asm_08004ff4.s"

#include "asm/code_08003980/asm_08005014.s"

#include "asm/code_08003980/asm_080050bc.s"

#include "asm/code_08003980/asm_08005124.s"

#include "asm/code_08003980/asm_08005188.s"

#include "asm/code_08003980/asm_080051a4.s"

#include "asm/code_08003980/asm_080051c4.s"

#include "asm/code_08003980/asm_080051f0.s"

#include "asm/code_08003980/asm_08005208.s"

#include "asm/code_08003980/asm_08005328.s"

#include "asm/code_08003980/asm_0800536c.s"

#include "asm/code_08003980/asm_08005424.s"

#include "asm/code_08003980/asm_080054b0.s"

#include "asm/code_08003980/asm_080054f0.s"

#include "asm/code_08003980/asm_080055fc.s"

#include "asm/code_08003980/asm_08005640.s"

#include "asm/code_08003980/asm_0800568c.s"

#include "asm/code_08003980/asm_08005814.s"

#include "asm/code_08003980/asm_0800584c.s"

#include "asm/code_08003980/asm_08005858.s"

#include "asm/code_08003980/asm_08005878.s"

#include "asm/code_08003980/asm_080058b0.s"

#include "asm/code_08003980/asm_080058dc.s"

#include "asm/code_08003980/asm_0800598c.s"

#include "asm/code_08003980/asm_08005a0c.s"

#include "asm/code_08003980/asm_08005a40.s"

#include "asm/code_08003980/asm_08005a84.s"

#include "asm/code_08003980/asm_08005ad4.s"

#include "asm/code_08003980/asm_08005b20.s"

#include "asm/code_08003980/asm_08005bc4.s"

#include "asm/code_08003980/asm_08005c00.s"

#include "asm/code_08003980/asm_08005c3c.s"

#include "asm/code_08003980/asm_08005c78.s"

#include "asm/code_08003980/asm_08005ca8.s"

#include "asm/code_08003980/asm_08005ce0.s"

#include "asm/code_08003980/asm_08005cec.s"

#include "asm/code_08003980/asm_08005d38.s"

#include "asm/code_08003980/asm_08005d74.s"

#include "asm/code_08003980/asm_08005db0.s"

#include "asm/code_08003980/asm_08005de4.s"

#include "asm/code_08003980/asm_08005e18.s"

#include "asm/code_08003980/asm_08005e54.s"

#include "asm/code_08003980/asm_08005ee4.s"

#include "asm/code_08003980/asm_08005f04.s"

#include "asm/code_08003980/asm_08005f34.s"

#include "asm/code_08003980/asm_08005fe4.s"

#include "asm/code_08003980/asm_080060bc.s"

#include "asm/code_08003980/asm_080061a4.s"

#include "asm/code_08003980/asm_080061d0.s"

#include "asm/code_08003980/asm_0800620c.s"

#include "asm/code_08003980/asm_08006328.s"

#include "asm/code_08003980/asm_08006364.s"

#include "asm/code_08003980/asm_0800637c.s"

#include "asm/code_08003980/asm_08006448.s"


// These functions handle allocation and deallocation from the main memory heap.
// The heap consists of a sequence of variable-sized blocks of data.
// Each block consists of a single word handle, immediately followed by the data the handle refers to.
// The handle stores the size of the block, if the block is currently allocated, and an ID.
// The size of the block can be used to get to the next handle, creating a singly linked list.

// The heap is initialised as a single unallocated block spanning the entire heap.
// Allocation works by first fit to find an unallocated block large enough for the requested data.
// If the block is larger than the required size, it will split the remainder of the block into a new smaller unallocated block.
// When a block is deallocated, the handle is simply marked as unallocated but the data is not cleared.
// Additionally, a deallocated block will be combined with the adjacent blocks if they are unallocated, to create one larger block.

extern void *mem_heap_alloc_block_rom;
extern void *mem_heap_alloc_block_rom_end;

static u32 mem_heap_alloc_block_code[20];
static s32 (*mem_heap_alloc_block)(u32 *memHeap, s32 memHeapSize, s32 length);

static u32 *sMemoryHeap;
static u32 sMemoryHeapLength;
#define MEM_HANDLE_ALLOCATED 0x8000

// Initialise the main memory heap.
void mem_heap_init(u32 *heapStart, u32 heapSize) {
    sMemoryHeap = heapStart;
    sMemoryHeapLength = heapSize / 4;

	// Make sure the memory heap does not extend outside of EWRAM.
    if (sMemoryHeapLength > 0xFFFF) {
        sMemoryHeapLength = 0xFFFF;
    }

	// Create the initial unallocated block's handle, spanning the length of the whole pool.
    sMemoryHeap[0] = sMemoryHeapLength << 16;

    D_03004ad0.unk0 = 0;
    D_03004ad0.unk4 = heapStart;
    D_03004ad0.unk8 = heapSize;
    D_03004ad0.unk10 = 0;
    D_03004ad0.unkC = 0;

	// The allocation function is handwritten assembly DMAd into IWRAM for performance.
	
	DmaCopy32(3, &mem_heap_alloc_block_rom, &mem_heap_alloc_block_code, ((uintptr_t)&mem_heap_alloc_block_rom_end - (uintptr_t)&mem_heap_alloc_block_rom));
    mem_heap_alloc_block = (void *)&mem_heap_alloc_block_code;
}


// Allocate a new block of memory from the memory heap with the default ID.
void *mem_heap_alloc(u32 size) {
	return mem_heap_alloc_id(0, size);
}


// Allocate from the memory heap with an ID.
void *mem_heap_alloc_id(u16 id, u32 size) {
    u32 blockLength = (size+3)/4 + 1; // Add 1 to the length so there is room for the block's handle as well.
	s32 oldBlockLength, blockEnd;
	
	// Find an unallocated block of memory using first fit.
    s32 newBlock = mem_heap_alloc_block(sMemoryHeap, sMemoryHeapLength, blockLength);

    if (newBlock < 0) {
		// There were no unallocated blocks large enough, abort the allocation.
        D_03004ad0.unk0 = 1;
        return NULL;
    }

    oldBlockLength = (u16)(sMemoryHeap[newBlock] >> 16);
	
	// Create the handle for the newly allocated block.
    sMemoryHeap[newBlock] = (blockLength << 16) | MEM_HANDLE_ALLOCATED | id;
	
    blockEnd = newBlock + blockLength;
	
	// If the requested block was smaller than the unallocated block it replaced,
	// we can turn the unused memory into a smaller unallocated block.
    if (blockLength < oldBlockLength) {
        sMemoryHeap[blockEnd] = (oldBlockLength - blockLength) << 16;
    }

    if ((blockEnd * 4) > D_03004ad0.unk10) {
        D_03004ad0.unk10 = (blockEnd * 4);
    }

	// Return the pointer to the allocated data, which is immediately after the new block's handle.
    return &(sMemoryHeap[newBlock]) + 1;
}


// Mark a block as deallocated and try to combine it with adjacent deallocated blocks, if possible.
void mem_heap_dealloc_block(u32 block, s32 prevBlock) {
    u32 nextBlock;

	// Clear the block's allocated flag and ID.
    sMemoryHeap[block] &= 0xFFFF0000;

	// If the preceding block is also unallocated, combine them into one larger block.
    if (prevBlock >= 0) {
        if ((sMemoryHeap[prevBlock] & MEM_HANDLE_ALLOCATED) == 0) {
            sMemoryHeap[prevBlock] += sMemoryHeap[block];
            block = prevBlock;
        }
    }

	// If the following block is also unallocated, combine them into one larger block.
    nextBlock = block + (sMemoryHeap[block] >> 16);
    if (nextBlock < sMemoryHeapLength) {
        if ((sMemoryHeap[nextBlock] & MEM_HANDLE_ALLOCATED) == 0) {
            sMemoryHeap[block] += sMemoryHeap[nextBlock];
        }
    }
}


// Deallocate the block belonging to a previously allocated section of data.
void mem_heap_dealloc(void *data) {
    s32 block, curBlock, prevBlock;

	// Make sure the data is word-aligned
    if ((uintptr_t)data & 0x3) {
        return;
    }
	
	// Get the location of the block's handle within the heap. Subtract 1 as the handle is immediately before the data.
    block = ((uintptr_t)data - (uintptr_t)sMemoryHeap) / 4 - 1;
	
    if ((block < 0) || (block >= sMemoryHeapLength)) {
		// Data is not part of the memory heap
        return;
    }

    prevBlock = -1;
    curBlock = 0;

    if (curBlock >= sMemoryHeapLength) {
        return;
    }

	// Iterate through the freelist to find the block and deallocate it.
	// This is required so that the previous block's handle can also be passed to the deallocation function,
	// as the freelist is only a singly linked list and so the previous block can't be obtained otherwise.
    while (curBlock <= block) {
        if (curBlock == block) {
            mem_heap_dealloc_block(block, prevBlock);
            break;
        }
		
        prevBlock = curBlock;
		curBlock += sMemoryHeap[curBlock] >> 16;
		
        if (curBlock >= sMemoryHeapLength) {
            break;
        }
    }
}


// Deallocate all blocks in the heap that have a specified ID.
void mem_heap_dealloc_with_id(u16 id) {
    s32 curBlock, prevBlock;
	u32 handleID;
    
	// Cannot deallocate blocks with the default ID.
    if (id == 0) {
        return;
    }

    prevBlock = -1;
	// The lower 16 bits of the handle, to match all allocated blocks with the given ID.
    handleID = id | MEM_HANDLE_ALLOCATED;
    curBlock = 0;

	// Iterate through the freelist and deallocate any block that matches the ID.
    while (curBlock < sMemoryHeapLength) {
        if ((u16)sMemoryHeap[curBlock] == handleID) {
            mem_heap_dealloc_block(curBlock, prevBlock);
        }

        prevBlock = curBlock;
        curBlock += sMemoryHeap[curBlock] >> 16;
    }
}


// Calculates the total amount of allocated data in the heap.
void mem_heap_get_allocated_space(void) {
    u32 allocatedWords = 0;
    u32 curBlock = 0;

	// Iterate through the freelist and store the total length of allocated data.
    while (curBlock < sMemoryHeapLength) {
        if (sMemoryHeap[curBlock] & MEM_HANDLE_ALLOCATED) {
            allocatedWords += sMemoryHeap[curBlock] >> 16;
        }
        curBlock += sMemoryHeap[curBlock] >> 16;
    }

    D_03004ad0.unkC = allocatedWords * 4;
}

#include "asm/code_08003980/asm_0800679c.s"

#include "asm/code_08003980/asm_080067a4.s"
